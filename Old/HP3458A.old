import pyvisa
import time
import numpy as np
import struct
import matplotlib.pyplot as plt

class HP3458A:
    def __init__(self, gpib_address: str = "GPIB0::22::INSTR", do_reset=True):
        self.rm = pyvisa.ResourceManager()
        try:
            self.instrument = self.rm.open_resource(gpib_address)
            self.instrument.timeout = 50000  # milisegundos
            self.instrument.read_termination = '\n'
            self.instrument.write_termination = '\n'
        except pyvisa.VisaIOError as e:
            raise ConnectionError(f"No se pudo abrir el recurso {gpib_address}: {e}")
        
        if do_reset:
            self.reset()

    def reset(self):
        """Resetea y limpia el instrumento."""
        self.instrument.write("*RST")
        self.instrument.write("*CLS")
        time.sleep(1)

    def identify(self) -> str:
        """
        Devuelve la identificación del instrumento.
        """
        try:
            return self.instrument.query("ID?").strip()
        except pyvisa.errors.VisaIOError:
            return "ID desconocido (no se pudo obtener respuesta)"

    def configure_measurement(self, mode="DCV", range_val=10, resolution=0.00001, nplc=10):
        """
        Configura el tipo de medición.
        mode: 'DCV' (voltaje DC), 'ACV' (voltaje AC), etc.
        """
        mode = mode.upper()
        if mode == "DCV":      
            self.instrument.write(f"DCV {range_val},{resolution}")
        elif mode == "ACV":
            self.instrument.write(f"ACV {range_val},{resolution}")
        else:
            raise ValueError(f"Modo de medición '{mode}' no soportado.")
        
        self.instrument.write(f"NPLC {nplc}")

    def measure_once(self) -> float:
        """
        Dispara una sola medición y devuelve el resultado.
        """
        self.instrument.write("INIT")
        self.instrument.write("*WAI")
        return float(self.instrument.query("FETCH?"))
    
    def measure_and_print(self, delay=1.0, max_samples=None):
        """
        Mide y muestra resultados en la terminal periódicamente.
    
        delay: tiempo en segundos entre mediciones.
        max_samples: cantidad máxima de mediciones a mostrar. None para infinito.
        """
        count = 0
        try:
            while max_samples is None or count < max_samples:
                valor = self.measure_once()
                print(f"Medición {count+1}: {valor}")
                count += 1
                time.sleep(delay)
        except KeyboardInterrupt:
            print("\nMedición interrumpida por el usuario.")
            
    def read_buffer(self, count=10) -> list:
        """
        Realiza múltiples mediciones usando el buffer interno del multímetro.
        """
        self.instrument.write("MFORMAT ASCII")
        self.instrument.write(f"MEM {count}")
        self.instrument.write("TARM SGL,1")
        self.instrument.write("TRIG")
        time.sleep(0.5)  # espera mínima, ajustar según NPLC y cantidad
        data = self.instrument.query("RMEM?")
        return [float(val) for val in data.strip().split(",") if val]

    def measure_sweep_binary(self, cant_muestras=10000, sweep_time=20e-6, aper_time=3e-6) -> np.ndarray:
        """
        Realiza una adquisición binaria tipo SWEEP.
        Devuelve los datos ya escalados en voltios como np.ndarray.
        """
        # Aumentar timeout por seguridad
        self.instrument.timeout = 50000

        # Configuración previa
        self.instrument.write('TRIG HOLD')
        self.instrument.write('TARM HOLD')

        # Configuración completa del barrido
        cmd = (
            f"AZERO OFF; PRESET FAST; MEM FIFO; MFORMAT SINT; OFORMAT SINT; TBUFF OFF; DELAY 0; "
            f"TRIG HOLD; TARM HOLD; DISP OFF, SAMPLING; "
            f"APER {aper_time}; DCV 1; SWEEP {sweep_time}, {cant_muestras}; "
            f"TARM SYN; TRIG EXT; MATH OFF"
        )
        self.instrument.write(cmd)

        # Armar y lanzar el trigger
        self.instrument.write("TARM")
        time.sleep(0.2)
        self.instrument.write("MEM:START?")

        # Leer los datos binarios
        bytes_por_lectura = 2
        raw_data = self.instrument.read_bytes(cant_muestras * bytes_por_lectura)

        # Desempaquetar y escalar
        muestras = struct.unpack(">" + "h" * cant_muestras, raw_data)
        escala = float(self.instrument.query("ISCALE?"))
        muestras_escaladas = np.asarray(muestras) * escala
        return muestras_escaladas

    def close(self):
        """Cierra la conexión con el instrumento."""
        if hasattr(self, 'instrument'):
            self.instrument.close()
        if hasattr(self, 'rm'):
            self.rm.close()

    def __enter__(self):
        """Permite usar la clase con 'with'."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
    
    def measure_and_plot_sweep(self, cant_muestras=10000, sweep_time=20e-6, aper_time=3e-6, bytes_por_lectura=2):
        """
        Realiza la medición tipo sweep con los parámetros indicados
        y muestra el resultado en un gráfico.
        """
        print("Iniciando medición sweep...")
        datos = self.measure_sweep_binary(cant_muestras=cant_muestras, sweep_time=sweep_time, aper_time=aper_time)

        # Eje temporal aproximado para el plot: 
        # cada muestra tarda sweep_time / cant_muestras segundos
        tiempo = np.linspace(0, sweep_time, cant_muestras)

        plt.figure(figsize=(10,5))
        plt.plot(tiempo * 1e6, datos)  # tiempo en microsegundos para mejor lectura
        plt.title("Medición Sweep Binary del HP3458A")
        plt.xlabel("Tiempo (µs)")
        plt.ylabel("Voltaje (V)")
        plt.grid(True)
        plt.show()
        
# Ejemplo de uso:
if __name__ == "__main__":
    with HP3458A("GPIB0::22::INSTR", do_reset=False) as multimetro:
        multimetro.instrument.timeout = 50000  # 30 segundos
        multimetro.reset()  # << Acá reiniciás el multímetro manualmente
        print("Identificación:", multimetro.identify())
        multimetro.configure_measurement(mode="DCV", range_val=10, resolution=0.00001)
        multimetro.measure_sweep_binary()
        multimetro.measure_and_plot_sweep()
        multimetro.reset()  # << Acá reiniciás el multímetro manualmente